import imaplib
from cryptography.fernet import Fernet
import configparser
import os
import logging
import traceback
import schedule
import time
import requests
from bs4 import BeautifulSoup
import re

SECRET_KEY = b'your_secret_key'

webhook_url = ''  # Replace with your actual webhook URL

config_path = r'your_path'
config = configparser.ConfigParser()
config.read(config_path)

encrypted_password = config['Credentials']['password']
cipher_suite = Fernet(SECRET_KEY)
password = cipher_suite.decrypt(encrypted_password.encode()).decode()

email = config['Credentials']['email']
server = config['IMAP']['server']
port = int(config['IMAP']['port'])

def extract_cve_numbers(email_body):
    cve_pattern = r'CVE-\d{4}-\d{4,7}'
    cve_matches = re.findall(cve_pattern, email_body)
    unique_cve_numbers = list(set(cve_matches))
    return unique_cve_numbers

def get_raw_cve_data(cve_number):
    try:
        cve_api_url = f'https://services.nvd.nist.gov/rest/json/cves/2.0?cveId={cve_number}'
        response = requests.get(cve_api_url)

        response.raise_for_status()

        raw_cve_data = response.json()
        return raw_cve_data

    except requests.RequestException as e:
        print(f"Error during HTTP request for raw CVE data: {str(e)}")
        return None
    except Exception as e:
        print(f"Error fetching raw CVE data: {str(e)}")
        traceback.print_exc()
        return None

def send_webhook(payload):
    print("Sending webhook with payload:", payload)
    try:
        response = requests.post(webhook_url, json=payload)

        if response.status_code == 200:
            print(f"Webhook sent successfully for email related to")
        else:
            print(f"Failed to send webhook for email related to ")
            print(f"Webhook response: {response.text}")

    except requests.RequestException as e:
        print(f"Error during webhook request: {str(e)}")

def get_cve_details(cve_number):
    print(cve_number)
    try:
        cve_api_url = f'https://services.nvd.nist.gov/rest/json/cves/2.0?cveId={cve_number}'
        response = requests.get(cve_api_url)

        response.raise_for_status()

        cve_data = response.json()
        print(f"Raw CVE data for {cve_number}: {cve_data}")
        print("cve_data",cve_data)
        requi_item ={}
        for i in cve_data["vulnerabilities"]:
            requi_item.update({"cve_id":i["cve"]["id"],
                               "value":i["cve"]["descriptions"][0]["value"]

            })
        print("req",requi_item)
            
        cve_items = cve_data.get('CVE_Items', [])
        

        if requi_item != {}:
            # cve_item = cve_items[0]
            # cve_description = cve_item.get('cve', {}).get('description', {}).get('description_data', [{}])[0].get(
            #     'value', 'No description available')
            # cve_published_date = cve_item.get('publishedDate', 'N/A')

            return requi_item, cve_data

        else:
             print(f"{cve_number} not found in NVD database")
             print("Complete cve_data:", cve_data)
             print("CVE Items:", cve_items)
             return 'N/A', 'N/A'

    except requests.RequestException as e:
        print(f"Error during HTTP request: {str(e)}")
        return 'N/A', 'N/A'
    except Exception as e:
        print(f"Error fetching CVE details: {str(e)}")
        traceback.print_exc()
        return 'N/A', 'N/A'

def check_emails_and_send_webhook(server, port, email, password):
    mail = None

    try:
        mail = imaplib.IMAP4_SSL(server, port)
        mail.login(email, password)
        mail.select("inbox")

        sender = "sender_of_the_email"
        result, data = mail.search(None, f'(FROM "{sender}" UNSEEN)')

        if result == 'OK':
            for num in data[0].split():
                result, msg_data = mail.fetch(num, '(RFC822)')
                if result == 'OK':
                    email_content = msg_data[0][1].decode('utf-8', 'ignore')
                    subject = email_content.split("Subject: ", 1)[1].split("\r\n", 1)[0]

                    if 'postgresql' in subject.lower():
                        product = 'Postgresql'
                    elif 'mysql' in subject.lower():
                        product = 'Mysql'
                    else:
                        product = 'Unknown Product'

                    unique_cve_numbers = extract_cve_numbers(email_content)
                    list_of_payload =[]
                    for cve_number in unique_cve_numbers:
                        # Call get_cve_details with each CVE number individually
                        cve_description, raw_data = get_cve_details(cve_number)

                        # Minimal payload even if get_cve_details returns None
                        payload = {
                            'product': product,
                            'subject': subject,
                            'cve_numbers': cve_description["cve_id"],  # Pass a list with a single CVE number
                            'cve_description': cve_description["value"],
                            'cve_published_date': time.time(),
                            'raw_cve_data': raw_data
                        }
                        list_of_payload.append(payload)
                    send_webhook(list_of_payload)

    except imaplib.IMAP4.error as e:
        logging.error(f"IMAP error: {str(e)}")
        traceback.print_exc()
    except Exception as e:
        logging.error(f"Error: {str(e)}")
        traceback.print_exc()
    finally:
        if mail is not None:
            try:
                mail.logout()
            except Exception as e:
                logging.error(f"Error during logout: {str(e)}")
                traceback.print_exc()

schedule.every(5).seconds.do(check_emails_and_send_webhook, server, port, email, password)

log_file = r'your_log_processing_path'
logging.basicConfig(filename=log_file, level=logging.INFO)

while True:
    schedule.run_pending()
    time.sleep(1)
